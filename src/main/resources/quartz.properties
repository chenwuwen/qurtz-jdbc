# 配置文件不是必须的，Quartz对配置项都是有默认值的，当需要自定义的时候，
# 可以在classpath路径下放一个quartz.properties文件，Quartz的StdSchedulerFactory
# 在启动时会自动加载该配置文件。
# 文件名不要改,quartz会自动加载改配置文件,在quartz的jar包下也有一个同名的配置文件
# 当我们在我们的项目中添加了quartz.properties的时候，我们需要把那些我们不需要修改的配置也加上，
# 并不能只有我们修改的配置。因为通过查看源代码我们可以知道，调度器在初始化的时候，首先判断我们是否有quartz.properties
# 如果有的话，就是用我们系统中的配置文件，否则就从jar包里加载quartz.properties进行默认的初始化。


#集群配置
org.quartz.scheduler.instanceName: DefaultQuartzScheduler
org.quartz.scheduler.rmi.export: false
org.quartz.scheduler.rmi.proxy: false

org.quartz.scheduler.wrapJobExecutionInUserTransaction: false

#===============================================================
# 配置线程池的属性
# Quartz定时任务默认都是并发执行的，不会等待上一次任务执行完毕，只要间隔时间到就会执行, 如果定时任执行太长，
# 会长时间占用资源，导致其它任务堵塞。可以通过在spring-quartz.xml中配置 concurrent为false解决 ,也可以使用注解
# https://my.oschina.net/blueskyer/blog/325812
# 可以想见,如果我们的任务都是配置的上一次执行完毕,再执行下一次的话,那我们就可以配置线程池的数量为我们的定时任务的数量
# 那么如果允许同一个定时任务并发执行,该怎么办呢？加入A任务1秒执行一次,每次执行用时20秒,任务B没2分钟执行一次,每次耗时10分钟
# 线程池定义数量为10,可以想见,由于A可以并发执行,到最后线程池肯定会被占满,当任务B想再去执行时,那么就需要排队了
# 所以根据自己的业务来选择,避免在定时任务中做一些长时间的操作,或者可以设置超时时间等等
#===============================================================

# 定义Quartz使用的线程池类型[SimpleThreadPool这个线程池没有任务队列,也就是如果线程池满了的话,会被拒接]
# 如果与Spring集成，使用org.springframework.scheduling.quartz.SchedulerFactoryBean且配置了taskExecutor（java.util.concurrent.Executor的实现类），
# 则会使用org.springframework.scheduling.quartz.LocalTaskExecutorThreadPool。
# 同时也可以自定义线程池,自定义线程池可以通过 org.quartz.threadPool.somePropOfFooThreadPool 来配置属性
org.quartz.threadPool.class: org.quartz.simpl.SimpleThreadPool
# 线程池里的线程数，默认值是10，当执行任务会并发执行多个耗时任务时，要根据业务特点选择线程池的大小
org.quartz.threadPool.threadCount: 10
# 线程优先级：可以是Thread.MIN_PRIORITY（即1）和Thread.MAX_PRIORITY（这是10）之间的任何int,默认值为Thread.NORM_PRIORITY（5）
org.quartz.threadPool.threadPriority: 5
org.quartz.threadPool.threadsInheritContextClassLoaderOfInitializingThread: true
# 可以设置为“true”，使池中的线程创建为守护进程线程。默认为“false”
org.quartz.threadPool.makeThreadsDaemons：false
# 可以是“true”或“false”，默认为false 在工作池中的线程名称的前缀将被附加一个数字。
org.quartz.threadPool.threadNamePrefix: true

#============================================================================
# Configure JobStore
# Quartz提供两种基本作业存储类型。第一种类型叫做RAMJobStore，第二种类型叫做JDBC作业存储。
# 在默认情况下Quartz将任务调度的运行信息保存在内存中，这种方法提供了最佳的性能，因为内存中数据访问最快。
# 不足之处是缺乏数据的持久性，当程序路途停止或系统崩溃时，所有运行的信息都会丢失。
# 比如我们希望安排一个执行100次的任务，如果执行到50次时系统崩溃了，系统重启时任务的执行计数器将从0开始。
# 在大多数实际的应用中，我们往往并不需要保存任务调度的现场数据，因为很少需要规划一个指定执行次数的任务。
# 对于仅执行一次的任务来说，其执行条件信息本身应该是已经持久化的业务数据（如锁定到期解锁任务，解锁的时间应该是业务数据），
# 当执行完成后，条件信息也会相应改变。当然调度现场信息不仅仅是记录运行次数，还包括调度规则、JobDataMap中的数据等等。
# 如果确实需要持久化任务调度信息，Quartz允许你通过调整其属性文件，将这些信息保存到数据库中。
# 使用数据库保存任务调度信息后，即使系统崩溃后重新启动，任务的调度信息将得到恢复。如前面所说的例子，执行50次崩溃后重新运行，
# 计数器将从51开始计数。使用了数据库保存信息的任务称为持久化任务。
#============================================================================

#默认配置，数据保存到内存
#org.quartz.jobStore.class: org.quartz.simpl.RAMJobStore

#持久化配置(也就是jdbc数据库的方式,将任务的定义[报错cron保存在数据库中])
org.quartz.jobStore.class:org.quartz.impl.jdbcjobstore.JobStoreTX
org.quartz.jobStore.driverDelegateClass:org.quartz.impl.jdbcjobstore.StdJDBCDelegate
org.quartz.jobStore.useProperties:true
#数据库表前缀[如果开启了持久化方式存储,那么Quartz会在数据库中创建表,表的创建需要手动创建：https://www.cnblogs.com/Rozdy/p/4269762.html,表创建SQL脚本：https://github.com/quartz-scheduler/quartz/tree/quartz-2.0.x/docs/dbTables]
#org.quartz.jobStore.tablePrefix:qrtz_
#org.quartz.jobStore.dataSource:qzDS
#容许的最大作业延长时间
org.quartz.jobStore.misfireThreshold: 60000
#调度实例失效检查时间间隔(默认是15秒)
org.quartz.jobStore.clusterCheckinInterval = 2000
#加入集群
org.quartz.jobStore.isClustered = true
#设置为TRUE不会出现序列化非字符串类到 BLOB 时产生的类版本问题
org.quartz.jobStore.useProperties = true

#============================================================================
# Configure Datasources
# 当开启了JDBC作业存储(默认是RAM存储),此时需要创建qurtz相关的表,那么表创建在哪个数据库,就可以在此处配置
# 同时也可以在spring-quartz.xml中,通过dataSource指定数据源,如果同时配置了,那么以spring-quartz.xml为准
#
#============================================================================
#JDBC驱动
org.quartz.dataSource.qzDS.driver:org.hsqldb.jdbc.JDBCDriver
org.quartz.dataSource.qzDS.URL:jdbc:hsqldb:file:db/qurtz_jbdc_demo;shutdown=true
org.quartz.dataSource.qzDS.user:kanyun
org.quartz.dataSource.qzDS.password:kanyun
org.quartz.dataSource.qzDS.maxConnection:10